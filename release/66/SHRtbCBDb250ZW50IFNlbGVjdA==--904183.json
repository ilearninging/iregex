{"id":"177471","urlID":"3bpjt","name":"Html Content Select","description":"","content":"<h1>\u6211\u662f\u6a19\u984c<\/h1>\n<p>\u6211\u662f\u5167\u5bb9<\/p>\n<p>\u524d\u7aef\u5de5\u7a0b\u5e08\u6216\u8bb8\u53ef\u4ee5\u5173\u6ce8\u4e00\u4e0b\u8fd9\u4e2aproject<\/p>\n<p>\u4e4b\u524d\u5199\u524d\u7aef\u6e38\u620f\u7684\u4f1a\u7528asm.js (\u8bdd\u8bf4\u8fd9\u4e2a\u597d\u50cf\u4e5f\u662fMozilla\u641e\u5f97) \u628a\u6548\u80fd\u5f80\u4e0a\u62c9<\/p>\n<p><a href=\"https:\/\/github.com\/WebAssembly\">https:\/\/github.com\/WebAssembly<\/a>\n<\/p>\n<p>&nbsp;<\/p>\n<p><a href=\"https:\/\/medium.com\/javascript-scene\/why-we-need-webassembly-an-interview-with-brendan-eich-7fb2a60b0723\">https:\/\/medium.com\/javascript-scene\/why-we-need-webassembly-an-interview-with-brendan-eich-7fb2a60b0723<\/a>\n<\/p>\n<p>&nbsp;<\/p>\n<div>\n    <div>\n        <div>\n            <div>\n                <div>\n                    <div>\n                        <h3>Why we Need WebAssembly<\/h3>\n                        <h2>An Interview with Brendan Eich<\/h2>\n                        <p>&nbsp;<\/p>\n                        <h4>Brendan Eich &amp; Eric Elliott Discuss WebAssembly Details &amp; Misconceptions<\/h4> <\/div>\n                <\/div>\n            <\/div>\n            <div>\n                <div>\n                    <div> &nbsp; <\/div>\n                <\/div>\n            <\/div>\n        <\/div>\n    <\/div>\n    <div>\n        <div>\n            <div> &nbsp; <\/div>\n        <\/div>\n    <\/div>\n<\/div>\n<div> &nbsp; <\/div>\n<div>\n    <div>\n        <p>Last week (June 17th, 2015),&nbsp;<a href=\"https:\/\/brendaneich.com\/2015\/06\/from-asm-js-to-webassembly\/\">Brendan Eich announced a new project<\/a>&nbsp;to bring new low level primitives to the web&#8202;\u2014&#8202;a move that will make it easier to compile projects written in languages like C &amp; C++ to run in browsers and other JavaScript environments. If this is your first time hearing about it, read&nbsp;<a href=\"https:\/\/medium.com\/javascript-scene\/what-is-webassembly-the-dawn-of-a-new-era-61256ec5a8f6\">\u201cWhat is WebAssembly\u201d<\/a>&nbsp;for a basic overview.<\/p>\n        <p>The WebAssembly team includes people from&nbsp; Google, Microsoft, Mozilla, Apple , and others under the banner of the&nbsp;<a href=\"https:\/\/www.w3.org\/community\/webassembly\/\"> W3C WebAssembly Community <b class=\"highlighted ner undefined Company system\" data-type=\"Company\" title=\"Company\">Group<\/b> <\/a>.<\/p>\n        <p>The announcement left the web development community speculating about how WebAssembly might impact the future of JavaScript.&nbsp; Brendan Eich fills in the gaps &nbsp;in an interview with Eric Elliott.<\/p>\n        <p> TL;DR: No Chicken Little, the sky is not falling. <\/p>\n        <p>All emphasis added.<\/p>\n        <p>&nbsp;<\/p> EE: &nbsp;Recently, you announced on your blog that we\u2019re getting something called WebAssembly. Basically an assembly language for the web, a low-level compile target. Can you tell us what that\u2019s about, and what motivated you to work on it?\n        <p> BE: &nbsp;Sure. This is in some ways just a continued process that started with ASM.js . ASM.js is a subset of JavaScript that has no objects and has no garbage collection or just in time compiler pauses. It\u2019s a target for C\/C++&#8202;\u2014&#8202;a statically typed subset of JavaScript. This was demonstrated at&nbsp; Mozilla &nbsp;in partnership with the <b class=\"highlighted ner undefined Company system\" data-type=\"Company\" title=\"Company\">big<\/b> gaming companies like&nbsp; Epic Games &nbsp;with Unreal Engine and&nbsp; Unity &nbsp;with the Unity engine and IDE.<\/p>\n        <p>So that allowed a lot of games published with those engines&#8202;\u2014&#8202;games out there in the market with Unreal Engine 3 and Unreal Engine 4, games built on Unity 5 to target JavaScript with just another instruction set.<\/p>\n        <p>These games would be possibly targeting&nbsp; PS4 ,&nbsp; XBox &nbsp;and&nbsp; PC. &nbsp;Now&nbsp; they could also be targeted at the web &nbsp;with&nbsp;<a href=\"https:\/\/en.wikipedia.org\/wiki\/WebGL\"> WebGL <\/a>&nbsp;and&nbsp;<a href=\"http:\/\/asmjs.org\/\"> ASM.js <\/a>, web audio and other APIs are important, gamepad APIs, full screen APIs all matter.<\/p>\n        <p> That was a <b class=\"highlighted ner undefined Company system\" data-type=\"Company\" title=\"Company\">big<\/b> success story at Mozilla &nbsp;when I was there and they actually crossed over to&nbsp; Microsoft . I remember talking a couple years ago to&nbsp; Anders Hejlsberg &nbsp;and&nbsp; Steve Lucco .&nbsp; Anders &nbsp;of course who did&nbsp; C# &nbsp;and &nbsp;.NET &nbsp;and Steve &nbsp;who led the&nbsp; Chakra &nbsp;team&#8202;\u2014&#8202;still does, I think. They were pretty enthusiastic about it, and so it came to pass that&nbsp; Edge supports ASM.js &nbsp;as an online optimized, whole module optimization just like Mozilla does, with good performance.<\/p>\n        <p>To put a not too fine a point on it, I think this was&nbsp; the last straw for Native Client , or really Portable Native Client (PNaCl) which was the only way Google &nbsp;was going to get their version of the compile to safe native story going for C &amp; C++ in browsers, and that was never even fully enabled in Chrome. &nbsp;It was whitelisted for certain Google properties. I think Google+ had an image editor.<\/p>\n        <p>As time went on, the fully native client wasn\u2019t going to cross to other browsers. It was a long road to do everything they intended to do. They were pretty ambitious. Whereas ASM.js started out looking like, oh, it doesn\u2019t have threads, it doesn\u2019t have locks, it doesn\u2019t have a lot of things they need in native code, it doesn\u2019t have&nbsp; SIMD &nbsp;(single instruction, multiple data), short vector intrinsics for vector units that are built into our modern CPUs.<\/p>\n        <p>Sure enough, JavaScript didn\u2019t have those things but now it\u2019s getting those things.&nbsp; SIMD &nbsp;is in&nbsp; Firefox &nbsp;nightly, it\u2019s&nbsp; coming to V8 , and Intel\u2019s already done an implementation in their version of V8,&nbsp; Crosswalk , and&nbsp; Microsoft announced SIMD support &nbsp;coming to&nbsp; Chakra .<\/p>\n        <p> Assuming stasis on the web&#8202;\u2014&#8202;it\u2019s not a good assumption , I think that was the mistake that happened long ago with projects like Portable Native Client and&nbsp; Dart , too. They assumed JavaScript was just incompetent, it could not get any better and therefore they had to do something that amounted to a whole second system, or third system to be added to browsers, and yet they couldn\u2019t get it fully into Chrome.<\/p>\n        <p>I\u2019m not gloating here. Realism requires incrementalism. All browsers must move in smaller steps. This is really a place where Firefox and Chrome restored browser competition&#8202;\u2014&#8202;Firefox first. Certainly there are alternative worlds, we saw one in the early 2000's with IE reaching 95% market share and Microsoft not investing in the web, instead investing in&nbsp; .NET &nbsp;and Windows Presentation Foundation , all that stuff.<\/p>\n        <p>Anyway to not go on about history,&nbsp; the continued evolution of ASM.js is wasm . The reason it\u2019s important is because once&nbsp; ASM.js crossed over &nbsp;into other browsers, it became clear that it was gonna cross over into&nbsp; all the browsers .<\/p>\n        <p>Yet JavaScript and even ASM.js, a subset of JavaScript, is missing SIMD, threads, shared memory and other primitives. Even with ASM.js, you\u2019re still parsing JavaScript. It\u2019s a subset. You might run a dedicated parser for that subset, which is another maintenance chore because now you\u2019ve got two parsers, one for the full JavaScript language and one for the subset.<\/p>\n        <p>You\u2019re still faced with&nbsp; a costly parsing problem &nbsp;compared to what could be done with a more efficient, compressed&nbsp; abstract syntax tree (AST) , which is what WebAssembly is aiming at.<\/p>\n        <p>People have been asking for&nbsp; bytecode &nbsp;on the web, thinking that they want Java bytecode. What I think the researchers at&nbsp; MSR &nbsp;and other places have shown is that they don\u2019t want that&#8202;\u2014&#8202;that bit back hard in several ways. AST encoding is much better.<\/p>\n        <p>At first,&nbsp; WebAssembly starts out just like ASM.js , but with a compressed syntax, that\u2019s a&nbsp; binary syntax . But once all the browsers support both wasm and ASM.js, and after a decent interval of browser updates, then&nbsp; wasm can start to grow extra semantics that need not be put into JavaScript .<\/p>\n        <p>They may in fact be put into both JavaScript and wasm because it\u2019s the same one engine &nbsp;(1vm), but there are certain things we might not want to ever put into JavaScript that could be put into wasm for the benefit of other languages like C++ or Haskell. There are lots of languages you might compile to wasm.<\/p>\n        <p>&nbsp;<\/p> EE: &nbsp;Could you give us some examples of that?\n        <p> BE:&nbsp; Sure, this is all&nbsp;<a href=\"https:\/\/github.com\/WebAssembly\/design#webassembly-community-&lt;b class=\" highlighted=\"\" ner=\"\" undefined=\"\" company=\"\" system \"=\" \" data-type=\"Company \" title=\"Company \">group-design\"&gt;written up in the GitHub<\/a>&nbsp;but just arguing for&nbsp; shared memory array buffers &nbsp;to get&nbsp; multi-threaded games &nbsp;cross-compiled was a stress on JavaScript because for the longest time we didn\u2019t want race conditions in JavaScript&#8202;\u2014&#8202;it\u2019s always a fragile process with bug hazards. That\u2019s an example of something we might have just kept in WebAssembly if we had that choice.<\/p>\n        <p>Down the road there are things like that, like&nbsp; zero cost exceptions &nbsp;might not make sense in JavaScript. They require some compiler and runtime cleverness, but they do make sense for C++, and Swift.<\/p>\n        <p>Another example is&nbsp; call\/cc &nbsp;(call-with-current-continuation ) . Call\/cc is too powerful a tool. It has&nbsp; challenges for JavaScript engines &nbsp;in implementation and&nbsp; security hazards .<\/p>\n        <p>You have these non-local functional gotos. You can call a continuation and be off in a different stack. So it\u2019s not like the local, limited continuations like we have in generators in ES6. It\u2019s a deeper continuation. So&nbsp; call\/cc could be put into wasm , into the engine that handles both wasm and JavaScript down the road. It\u2019s conceivable. It won\u2019t go to the JavaScript language but to the WebAssembly syntax in a way that won\u2019t affect the legacy JavaScript world.<\/p>\n        <p>&nbsp;<\/p> EE: &nbsp;Speaking of which, are there security implications to wasm that we need to think carefully about?\n        <p> BE: &nbsp;As it starts as co-expressive with ASM.js, it&nbsp; doesn\u2019t add any new security issues &nbsp;right out of the gate, but as it starts to diverge a year or two down the road, then&nbsp; yes, we need to look at the security properties of all those extensions . That\u2019s an added challenge. That\u2019s something that the native client folks at Google have been thinking of a lot. They\u2019re helping and their knowledge in this area is helpful.<\/p>\n        <p>We\u2019re trying to chase undefined behavior out of C++ and the&nbsp;<a href=\"http:\/\/llvm.org\/\"> LLVM <\/a>compiler that&nbsp;<a href=\"https:\/\/developer.chrome.com\/native-client\/overview\"> PNaCl (Portable Native Client) <\/a>&nbsp;uses, and&nbsp;<a href=\"https:\/\/github.com\/kripken\/emscripten\"> Emscripten <\/a>&nbsp;also uses. From the hardware up to the specification for C++, there\u2019s a lot of undefined behavior, and that\u2019s not good for security.<\/p>\n        <p>JavaScript has been a lot more prescriptive and is trying to be safer than a lot of other languages. For WebAssembly we need to go more to the JavaScript side.<\/p>\n        <p>&nbsp;<\/p> EE: &nbsp;There was an interesting headline in the register. Are you trying to KILL JavaScript? Is that what this is all about?\n        <p> BE: &nbsp;[laughs] No. I\u2019m a pragmatist. I\u2019m an old C\/C++ hacker. This is all a <b class=\"highlighted ner undefined Company system\" data-type=\"Company\" title=\"Company\">big<\/b> system that evolves. Humans trying things, but also facing real compatibility constraints on the web.<\/p>\n        <p>You don\u2019t break the web, you don\u2019t get to clean the slate and start over. Anybody who tries is going to fail. Even when you look at native apps on mobile devices, where there are fairly mature native languages and toolkits for user interface and graphics, there\u2019s still a lot of web. There\u2019s a lot of hybrid apps.<\/p>\n        <p> Facebook &nbsp;still uses web views. All the <b class=\"highlighted ner undefined Company system\" data-type=\"Company\" title=\"Company\">big<\/b> apps&#8202;\u2014&#8202; Amazon ,&nbsp; Pinterest, &nbsp;and so on use web views. There\u2019s a lot of web assets that would be completely insane to reinvent with native presentation layers instead of HTML. So the web is still pretty darn important. It\u2019s also the highest monetization platform.<\/p>\n        <p>Smartphones have incredible penetration. There will be a smartphone for almost every adult on the planet within a few years, and that\u2019s gonna be huge for many things, but that doesn\u2019t really mean a smartphone\u2019s a PC. It\u2019s still more of a consumption device. It\u2019s not like you\u2019re sitting and typing and researching and shopping in depth.<\/p>\n        <p>So rather than kill JavaScript, which is&nbsp; not feasible , what I\u2019m trying to do is respond to real engineering problems that we\u2019ve had with ASM.js. Loading a <b class=\"highlighted ner undefined Company system\" data-type=\"Company\" title=\"Company\">big<\/b> game from Epic or Unity can take 20 - 30 seconds. That\u2019s too long. With a compressed abstract syntax tree encoding that\u2019s 20 times faster, just a couple seconds, that\u2019s what you want. So&nbsp; there\u2019s a real reason for wasm , and it is a valid reason.<\/p> [Read the&nbsp; <a href=\"http:\/\/blogs.unity3d.com\/2015\/06\/18\/webgl-webassembly-and-feature-roadmap\/\">Unity Blog post<\/a>&nbsp;to learn how WebAssembly could dramatically improve the gaming experience.]\n        <p>Wasm&nbsp; helps &nbsp;JS win, it is a win not only for native code compilation. Eventually all the browsers and webviews will support wasm syntax to serve the compile target master and free JavaScript so it can serve the JavaScript master.<\/p>\n        <p>JavaScript has been in that house divided stage, and it never works in the long run. Like I said, even the shared array buffer extension, that\u2019s a bit of a stretch for JavaScript, and having the ability down the road to let wasm do the exotic things that C++ wants and not needing to figure out ways to put those less-safe facilities into JavaScript is a great relief.<\/p>\n        <p>So, parsing performance, and not serving two masters, those are good reasons to do wasm.&nbsp; We\u2019re not killing JavaScript. I don\u2019t think it\u2019s even possible to kill JavaScript. <\/p>\n    <\/div>\n<\/div>\n<div> <\/div>\n<div>\n    <div> \u201cThe sky is not falling.\u201d <\/div>\n<\/div>\n<div> <\/div>\n<div>\n    <div> EE: &nbsp;That\u2019s good news for a lot of people who have been a little bit worried about that. In fact, I think that was the most common response I saw on the internet to the wasm announcement. People were afraid that the sky is falling.&nbsp; I think we can safely say that the sky is not falling, and that JavaScript will stick around for a while.\n        <p> BE: &nbsp;I think given the privileged position JavaScript has, and how&nbsp; wasm is really starting out as a target for static languages like C++ , it\u2019s gonna be a while before we get other future extensions to wasm like garbage collection and just-in-time compile to wasm, features we need for dynamic languages to perform well, that\u2019s gonna take a while to do, too.<\/p>\n        <p>In the meantime, people at Google doing the&nbsp; Dart compiler , they\u2019re gonna stick with JavaScript &nbsp;because when you aren\u2019t compiling in checked mode, Dart code is really dynamic code&#8202;\u2014&#8202;it needs JavaScript\u2019s JITs (Just In Time compiles). It needs polymorphic inline cache and other optimizations.<\/p>\n        <p>Ideally we\u2019ll get things in JavaScript like <b class=\"highlighted ner undefined Company system\" data-type=\"Company\" title=\"Company\">big<\/b> integers\/bignums that Dart has that JavaScript doesn\u2019t yet, which is on the agenda for future ECMAScript. I think JavaScript\u2019s gonna be around as long as that. It\u2019s really hard to say at any point that we can get rid of&nbsp; JavaScript as the built in and the only built in high-level language in browsers. <\/p>\n        <p>&nbsp;<\/p> EE: &nbsp;Back in the 90's, I used to write a lot of C\/C++ myself. I grew up in the demoscene. I don\u2019t know if you\u2019re familiar, but we basically built art applications, like a movie that\u2019s running live code instead of prerecorded video. Back then we used to&nbsp; drop into assembly language &nbsp;all the time to do things like video processing or audio processing, or effects like that where there\u2019s a lot of data crunching.&nbsp; Do you see wasm as a useful tool for people building those kinds of applications?\n        <p> BE: &nbsp;I do. I should mention that we have SIMD coming to JavaScript. We\u2019ve already had WebGL going back almost 10 years now.&nbsp;<a href=\"https:\/\/twitter.com\/vvuk\"> Vladimir Vuki\u0107evi\u0107 <\/a>&nbsp;at Mozilla started out doing it in and it went into the&nbsp;<a href=\"https:\/\/www.khronos.org\/\">Khronos <b class=\"highlighted ner undefined Company system\" data-type=\"Company\" title=\"Company\">Group<\/b><\/a>, and it\u2019s great to have WebGL as part of the foundation that supports the <b class=\"highlighted ner undefined Company system\" data-type=\"Company\" title=\"Company\">big<\/b> games from Epic, Unity, and others.<\/p>\n        <p>However it\u2019s only based on&nbsp; OpenGL ES , the Mobile profile of&nbsp;<a href=\"https:\/\/en.wikipedia.org\/wiki\/OpenGL\"> OpenGL <\/a>. It\u2019s only just been uplifted from OpenGL ES2 to 3 point something in WebGL 2. So when you look at desktop GPUs, they can do a lot more. Wasm could have OpenGL 4, the latest and greatest desktop with all the fancy extra shaders and target all the insane Nvidia GPUs that are out there.<\/p>\n        <p>And maybe those GPUs will trickle down into mobile devices, but it\u2019ll take a while. Whatever happens with WebGL, with wasm we have an option over the next few years to do even more to-the-metal programming, including those advanced GPUs.<\/p>\n        <p>&nbsp;<\/p> EE: &nbsp;Who\u2019s involved in this? I know you\u2019ve mentioned in your blog that people from Microsoft and Google, who all is involved, and where are we gonna see support coming from?\n        <p> BE: &nbsp;It\u2019s hard for me since I\u2019m an outsider to make announcements for other companies, and you may have noticed, one company couldn\u2019t quite get its name lent, but it was only a matter of the usual protocol delays. There was no hardship there, and the principal there who works on&nbsp;<a href=\"https:\/\/www.webkit.org\/\">WebKit<\/a>&nbsp;and<a href=\"https:\/\/trac.webkit.org\/wiki\/JavaScriptCore\">JavaScriptCore<\/a>,&nbsp;<a href=\"http:\/\/www.filpizlo.com\/\">Filip Pizlo<\/a>&nbsp;whose name is obviously active in the&nbsp;<a href=\"https:\/\/github.com\/WebAssembly\">GitHub repositories<\/a>&nbsp;(the WebAssembly GitHub account).<\/p>\n        <p>Filip works for&nbsp; Apple . The other companies that did name themselves are Microsoft, Mozilla, &nbsp;and&nbsp; Google .<\/p>\n        <p>Mozilla really pioneered this with ASM.js, but the Google folks on PNaCl , had also been solving a lot of the same problems and wringing out undefined behavior, thinking about more advanced features that ASM.js doesn\u2019t currently support like dynamic linking and threads before we got around to doing the shared array buffer.<\/p>\n        <p>I think at some point it was time to heal the rift. I think on&nbsp;<a href=\"https:\/\/news.ycombinator.com\/\">Hacker News<\/a>&nbsp;a lot of people think I\u2019m a <b class=\"highlighted ner undefined Company system\" data-type=\"Company\" title=\"Company\">big<\/b> jerk because somehow from my throne of skulls at Mozilla I manage to mentally control everybody in the industry to stop PNaCl from coming to other browsers, or that if I\u2019d just put it into Mozilla (at great cost) then everybody else would get in line&nbsp; because if Mozilla and Google do something, everybody else must do it. &nbsp;Not so, see WebM.<\/p>\n    <\/div>\n    <div>\n        <div>\n            <div> &nbsp; <\/div> <img src=\"https:\/\/d262ilb51hltx0.cloudfront.net\/max\/1642\/1*w-52fSYad5Npdlqwk8oSTQ.png\"> <\/div> Mozilla office photo by&nbsp; <a href=\"https:\/\/twitter.com\/mart3ll\">@mart3ll<\/a>&#8202;\u2014&#8202; <a href=\"https:\/\/news.ycombinator.com\/item?id=9555028\">Eye-witness testimony<\/a> <\/div>\n    <div>\n        <p>So there I think there are a lot of hard feelings from people who are not facing reality. The fact is PNaCl is not gonna go cross-browser, but a lot of the work was LLVM based. It was getting ahead of what we did with ASM.js, so it\u2019s the perfect marriage now. It was originally considered ill-starred, but it\u2019s actually turning out great to have people working on WebAssembly who used to work on ASM.js and PNaCl.<\/p>\n        <p>&nbsp;<\/p> EE: &nbsp;Given all the support behind it, when can we expect to start seeing built-in browser support for wasm?\n        <p> BE:&nbsp; I don\u2019t know, they still have to build a prototype or something that can evolve, because one of the things we learned with JavaScript, and HTML for that matter is you don\u2019t get to do a lot of hard versions. You end up floating something that has object detection or feature detection, or some autoconf testing facility so that you can write code defensively to degrade gracefully.<\/p>\n        <p>So that if, in a few years when wasm 2018 has call\/cc in it, maybe some other languages are just out of luck, but if it also has some advanced feature like zero cost exceptions, you want to run on a browser with wasm 2017 without zero cost exceptions, maybe you just take a greater hit for your exception calls. Maybe that\u2019s OK.<\/p>\n        <p>There\u2019s going to be something very important from JavaScript programming we\u2019ve dubbed&nbsp; 1JS &nbsp;which is for mimetype versioning that we were using for ES4 about 8 years ago. It is codified in&nbsp;<a href=\"https:\/\/www.rfc-editor.org\/rfc\/rfc4329.txt\">RFC 4329<\/a>&nbsp;Bjoern Hoehrmann\u2019s writeup of the&nbsp; `&lt;script type=\u201dapplication\/ecmascript\u201d&gt;` &nbsp;for JavaScript. He says there\u2019s a version parameter. It doesn\u2019t say what the values of the version are, (but you can\u2019t ignore it), but people are always gonna get versions wrong, and mimetypes wrong or write script tags without any mimetype.<\/p>\n        <p>This whole idea of version locking failed and rightly so, and I think it\u2019s been a problem in general in other runtime systems that tried it. What I expect will happen is in the next few months, they\u2019ll get to a point where they\u2019re happy with the abstract syntax tree encoding performance, with the trade-off between encode efficiency and decode efficiency, where decode is most important. They\u2019ll have a good idea of how to extend the syntax.<\/p>\n        <p>Then they can start shipping it in nightlies. I would expect sometime&#8202;\u2014&#8202;I would think by next year&#8202;\u2014&#8202;but this is totally a guess, right, I don\u2019t have a crystal ball. But we\u2019ll start seeing at least nightly browsers have wasm support maybe even sooner, it could be this fall.<\/p>\n    <\/div>\n<\/div>\n<div> <\/div>\n<div>\n    <div> \u201cI would think by next year \u2014\n        <br> but this is totally a guess.\u201d <\/div>\n<\/div>\n<div> <\/div>\n<div>\n    <div>\n        <p>Soon enough, the community <b class=\"highlighted ner undefined Company system\" data-type=\"Company\" title=\"Company\">group<\/b> will start thinking about standardizing the syntax. The one thing that makes this even less of a pressing issue is that there\u2019s already what they call a polyfill&#8202;\u2014&#8202;it\u2019s really just a library&#8202;\u2014&#8202;a JavaScript version of a decoder for the prototype abstract syntaxt tree that goes from that binary code back to ASM.js.<\/p>\n        <p>Even now JavaScript has sort of soft-launched wasm without having to commit to the exact syntax. The key with web standards as always in the modern HTML5 era is to iterate, not to try to do some giant 10 year spec and get it all right instantly, and any time that seemed to happen like with ES4, which was a <b class=\"highlighted ner undefined Company system\" data-type=\"Company\" title=\"Company\">big<\/b> refactor, or ES6 which was large, the only thing that saved it was the incremental prototype that was going on in the real engines.<\/p>\n        <p>HTML5 had this patina of being a <b class=\"highlighted ner undefined Company system\" data-type=\"Company\" title=\"Company\">big<\/b>, multi-year version that ended with a giant version stamp 5, but in fact it was already rolling out the parts years before anybody said it was done.<\/p>\n        <p>&nbsp;<\/p> EE: &nbsp;You mentioned a prototype, is that something that people can download and play with and take a look at right now?\n        <p> BE:&nbsp; Yeah, I believe so, if you go to the GitHub account, WebAssembly and you look under&nbsp;<a href=\"https:\/\/github.com\/WebAssembly\/polyfill-prototype-1\">polyfill-prototype-1<\/a>&nbsp;you\u2019ll see a decoder. I haven\u2019t had any time but if you look at&nbsp;<a href=\"https:\/\/github.com\/kripken\/emscripten\">Emscripten<\/a>&#8202;\u2014&#8202;Emscripten is going to support this with an optional mode using the polyfill, the library JavaScript decoder, and that I think is already being experimented right now.<\/p>\n        <p>&nbsp;<\/p> EE: &nbsp;As all these things come into wasm, is JavaScript still gonna see some of the low-level features that you talked about in your talk, \u201cTaking the High Road and the Low Road\u201d?\n        <div> <\/div>\n        <p> BE: &nbsp;Yeah, like I said, wasm down the road when it\u2019s supported and you don\u2019t need the polyfill, then it can be safely more expressive than ASM.js. It can have bigger semantics, however, that\u2019ll be a while.<\/p>\n        <p>In the meantime a lot of stuff has to go into JavaScript anyway because people want it even if they\u2019re not compiling. They want it for hand-coding. This is true of SIMD, this is true of a lot of the stuff that we\u2019ve been uplifting the&nbsp; `Math` &nbsp;object for, intrinsics, things that you might get in&nbsp;<a href=\"https:\/\/en.wikipedia.org\/wiki\/C_mathematical_functions\"> libm <\/a>&nbsp;if you were in C code or C++ code, there are some things that ES6 added and there are a few more things on our agenda, still.<\/p>\n        <p>I think we\u2019ll still take the low road as well as the high road, but I think in maybe 5 years\u2019 time frame, we wouldn\u2019t have to sweat it so much, and if there was something that was low-road that was only for compilers and we\u2019re pretty sure wouldn\u2019t be needed by JavaScript hand coders, then we could leave it out of JavaScript, and that\u2019s part of not serving two masters.<\/p>\n        <p>&nbsp;<\/p> EE:&nbsp; Do you think this is gonna cause a lot of language fragmentation, or is it diversity, and what\u2019s difference? Is this a good thing or a bad thing? A lot of people seem to be confused about that.\n        <p> BE: &nbsp;I think that&nbsp; JavaScript\u2019s got the unique dynamic language built into the browser status , but wasm can support many compiled languages, certainly the static ones right now&#8202;\u2014&#8202;particularly the ones that use LLVM. Microsoft has their own compiler so they\u2019ll be doing wasm from a different compiler framework, but that\u2019s great. The more, the merrier.<\/p>\n        <p>Certainly&nbsp;<a href=\"https:\/\/gcc.gnu.org\/\">GCC<\/a>&nbsp;or similar could generate wasm, but I think to get to the dynamic languages, like I mentioned&nbsp; Dart, &nbsp;or &nbsp;Ruby, &nbsp;or &nbsp;Python, even JavaScript&#8202;\u2014&#8202;that\u2019s gonna require some extensions &nbsp;that I mentioned earlier, like: garbage collection hooks, JIT support, things like that. Otherwise they just won\u2019t be competitive.<\/p>\n        <p>There\u2019s good precedent. The JVM grew over many years, thanks to&nbsp;<a href=\"https:\/\/www.java.net\/jcp\/communityspotlight\/john-rose\">John Rose<\/a>&nbsp;grew things like&nbsp; `invokedynamic` &nbsp;and other hooks for just in time compilation optimizations like polymorphic inline caching so the JVM is actually a credible dynamic language platform.<\/p>\n        <p>All of these runtimes have become polyglot VMs&#8202;\u2014&#8202;JavaScript VMs. Java hasn\u2019t died just because the JVM now supports Clojure, and Scala, and other languages. We\u2019re almost at the second golden age of programming languages, you know, take Rust, Haskell, Idris, and other languages.<\/p>\n        <p>The more the merrier, I say. It\u2019s not gonna become the tower of Babel because I think JavaScript will be the lingua franca of the browser, today and tomorrow. If you\u2019re writing front-end code or really anything that\u2019s not on the critical path when you profile.<\/p>\n    <\/div>\n<\/div>\n<div> <\/div>\n<div>\n    <div> \u201cThe more the merrier, I say.\u201d <\/div>\n<\/div>\n<div> <\/div>\n<div>\n    <div>\n        <p>But if you really wanna map those intense 3d games, or some really complicated computer vision kernel algorithm, then you might reach for C++ or something that compiles to wasm, and in five years, if people are enthusiastic about some new language that compiles to wasm, then that language should rise, and I don\u2019t think that\u2019s a problem, I think that\u2019s just a part of life in the <b class=\"highlighted ner undefined Company system\" data-type=\"Company\" title=\"Company\">big<\/b> city.<\/p>\n        <p>&nbsp;<\/p> EE: &nbsp;So you do eventually want to see JavaScript get killed off if something better comes along?\n        <p> BE: &nbsp;Again, I don\u2019t foresee how it can be killed off because all the content on the web has to run within the browsers and a JavaScript runtime implemented in wasm would be a real challenge to engineer to be just as fast as V8 is. But many many years down the road, if someone did that, then you could just make JavaScript one of&nbsp; n &nbsp;wasm implemented languages.<\/p>\n    <\/div>\n<\/div>\n<div> <\/div>\n<div>\n    <div> \u201cHey this isn\u2019t the JavaScript I remember\n        <br> \u2014 this is pretty good!\u201d <\/div>\n<\/div>\n<div> <\/div>\n<div>\n    <div>\n        <p>But it\u2019d still be this language that has such a great foothold on the web. And it also has evolved because we\u2019re still working on making JavaScript a better language for hand-coders, so it\u2019s not sitting still. ES6 has people saying, \u201chey this isn\u2019t the JavaScript I remember&#8202;\u2014&#8202;this is pretty good!\u201d<\/p>\n        <p>Again, have no crystal ball, I just think it would be very hard to kill JavaScript. I\u2019m not&nbsp; trying &nbsp;to kill JavaScript. I have no particular need to see JavaScript live any longer than it needs to, and if people find other languages better in the long run, and if down the road, we go through so many iterations that it doesn\u2019t matter that it\u2019s JavaScript built into the browser, then I say,&nbsp; \u201cque sera sera.\u201d <\/p>\n        <p>I really think that people who want JavaScript to fail because they\u2019re hostile to it for some reason or other are gonna be disappointed. It\u2019s not going away.<\/p>\n        <p>This is actually good for both JavaScript and other languages. Don\u2019t assume stasis. I think wasm will grow to include lots and lots of expressiveness for lots and lots of languages, JavaScript included.<\/p>\n        <p>This is one of those instances where everybody can win. That really fits everybody\u2019s wishlist for the web, whether it\u2019s Apple, or Google, or Microsoft, or Mozilla.<\/p>\n        <p>The thing to do now is to focus on incremental improvements, not to try to get too far ahead of reality. Things like ES4, or PNaCl or Dart, or XHTML back in its day. All these <b class=\"highlighted ner undefined Company system\" data-type=\"Company\" title=\"Company\">big<\/b> bangs that try to remake the web in its own grand planned fashion do not work.<\/p>\n        <p>So now that we have all these people cooperating on these little bangs, we should see a series of little bangs that have great cumulative effect.<\/p>\n        <p> \/be <\/p>\n    <\/div>\n<\/div>","weightedVote":"2.5","numVotes":"0","author":"","community":"1","dateAdded":"2015-09-14","pattern":"(<\\\/?[\\w\\s=\"\/.':;#-\\\/]+>)?Chakra .((\\s*|&nbsp;*)|(<\\\/?[\\w\\s=\"\/.':;#-\\\/]+>)*|(\\s*|&nbsp;*))*Assuming(<\\\/?[\\w\\s=\"\/.':;#-\\\/]+>)?","replace":"","state":"{\"substEnabled\":false}"}